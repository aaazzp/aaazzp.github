<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>aaaZzp&#39;s Blog</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习学习学习努力努力努力">
<meta property="og:type" content="website">
<meta property="og:title" content="aaaZzp&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="aaaZzp&#39;s Blog">
<meta property="og:description" content="学习学习学习努力努力努力">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="aaaZzp&#39;s Blog">
<meta name="twitter:description" content="学习学习学习努力努力努力">
  
    <link rel="alternative" href="/atom.xml" title="aaaZzp&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1523511642537&di=b8b4c9f4963900a0d1e3ba5f61b27dcd&imgtype=0&src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F011f7e554b47b8000001bf7216351e.jpg%401280w_1l_2o_100sh.png">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1523511642537&amp;di=b8b4c9f4963900a0d1e3ba5f61b27dcd&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F011f7e554b47b8000001bf7216351e.jpg%401280w_1l_2o_100sh.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">起白</a></h1>
		</hgroup>

		
		<p class="header-subtitle">学习学习学习努力努力努力</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">起白</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1523511642537&amp;di=b8b4c9f4963900a0d1e3ba5f61b27dcd&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F011f7e554b47b8000001bf7216351e.jpg%401280w_1l_2o_100sh.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">起白</h1>
			</hgroup>
			
			<p class="header-subtitle">学习学习学习努力努力努力</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Java知识点：注解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/14/Java知识点：注解/" class="article-date">
  	<time datetime="2018-06-14T13:44:20.729Z" itemprop="datePublished">2018-06-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/14/Java知识点：注解/">
        Java知识点：注解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    注解，是一种在代码中添加信息提供的一种形式化的方法，使我们可以在稍后的某个时刻方便地使用这些数据。Java中提供了三种标注注解和四种元注解（负责注解其他的注解）。</p>
<h5 id="标准注解"><a href="#标准注解" class="headerlink" title="标准注解"></a>标准注解</h5><ol>
<li>@Override:当前方法定义将覆盖超类中的方法。</li>
<li>@Deprecated:表明当使用了注解为元素，编译器会发出警告信息。</li>
<li>@SuppressWarnings:关闭不当的编译器警告信息。</li>
</ol>
<h5 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h5><ol>
<li>@Target:表示该注解可以用于什么地方，可选参数有：CONSTRUCTOR(构造器的声明)、FIELD(域声明)、LOCAL_VARIABLE(局部变量声明)、METHOD(方法声明)、PACKAGE(包声明)、PARAMETER(参数声明)、TYPE(类、接口或enum声明)。</li>
<li>@Retention:表示需要在什么级别保存该注解信息。可选有：SOURCE(注解将被编译器丢弃)、CLASS(注解在class文件中可用，但会被VM丢弃)、RUNTIME(VM在运行期也保留注解，因此可以通过反射机制读取注解信息)。</li>
<li>@Documented:将此注解包含在javadoc中</li>
<li>@Inherited:允许子类继承父类中的注解。</li>
</ol>
<h5 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h5><p>​    注解也会被编译成class文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Notation&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">descrition</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">this</span> is <span class="keyword">default</span> value"</span>;</span><br><span class="line">    <span class="comment">//defalut为没有传入声明字符串的默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="编写注解处理器"><a href="#编写注解处理器" class="headerlink" title="编写注解处理器"></a>编写注解处理器</h5><p>​    编写Notation注解处理器如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotationTracker</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">void</span> <span class="params">(List&lt;Integer&gt; notations,Class&lt;?&gt; cl)</span></span>&#123;</span><br><span class="line">        <span class="comment">//getDeclareMethods方法与getAnnotation方法均属于AnnotatedElement接口</span></span><br><span class="line">        <span class="keyword">for</span>(Method m : cl.getDeclareMethods)&#123;</span><br><span class="line">            </span><br><span class="line">            Notation n = m.getAnnotation(Notation.class);<span class="comment">//返回指定类型的注解对象</span></span><br><span class="line">            <span class="keyword">if</span>(n != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//print...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : notations)&#123;</span><br><span class="line">            <span class="comment">//print</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h5><p>​    注解元素可用的类型可包括：所有的基本类型，String，Class，enum，Anotation以及以上类型的数组。</p>
<h5 id="默认值限制"><a href="#默认值限制" class="headerlink" title="默认值限制"></a>默认值限制</h5><p>​    注解要么具有默认值，要么在使用注解时提供元素的值。</p>
<h5 id="基于注解的单元测试"><a href="#基于注解的单元测试" class="headerlink" title="基于注解的单元测试"></a>基于注解的单元测试</h5><p>​    单元测试是对类中的每个方法提供一个或多个测试的一种实践。这种基于注解的测试框架叫做@Unit。其中，使用最基本的一个注解为@Test。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android线程与线程池" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/11/Android线程与线程池/" class="article-date">
  	<time datetime="2018-06-11T09:19:20.182Z" itemprop="datePublished">2018-06-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/11/Android线程与线程池/">
        Android线程与线程池
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    在Android中，线程在用途上分为主线程与子线程，主线程主要处理和界面相关的事情，而子线程则用于执行耗时操作。</p>
<p>​    在Android中，除Thread外，AsyncTask（底层用到了线程池）、IntentService（底层用了线程），HandlerThread（底层用了线程）也是一种线程。</p>
<p>​    由于线程是一种受限的系统资源，所以频繁地对其进行创建与销毁，会造成比较大的开销，正确的做法应该是采用线程池，在线程池中会缓存一定数量的线程，通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。</p>
<p>​    Android中的线程池来源于Java，只要是通过Executor来派生特定类型的线程池。</p>
<h4 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h4><p>​    主线程是指进程所拥有的进程，在Java中默认情况下一个进程只有一个线程（主线程）。主线程主要处理界面交互相关的逻辑，因为交互是随时进行的，所以主线程在任何时候都必须有较高的响应速度。因此，在主线程中就不能执行耗时的操作，只能交由子线程执行。</p>
<p>​    Android中同理。其中，主线程是指UI线程，其作用是运行四大组件以及处理它们与用户的交互。耗时操作不能在主线程中执行，否则会被阻塞出现ANR现象。</p>
<h4 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h4><h5 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h5><p>​    它是一种轻量级的异步任务类，可以在线程池中执行后台任务，然后把进度和结果传递给主线程并在主线程中更新UI。它封装了Thread和Handler。通过它可以更方便地执行后台任务以及在主线程中访问UI，但并不适合进行特别耗时的后台任务。</p>
<p>​    AsyncTask是一个抽象的泛型类，提供了Params：表示参数类型、Progress：表示后台任务的执行速度的类型、Result：表示后台任务的返回结果类型，三个泛型参数，如果不需要传递具体的参数，可以用Void来代替。</p>
<p>​    AsyncTask提供了4个核心方法：</p>
<p>​    1.onPreExecute()：在主线程中执行，在异步任务执行之前，此方法会被调用，一般用于做一些准备工作。</p>
<p>​    2.doInBackground(Params…params)：在线程池中执行，用于执行异步任务，params表示异步任务输入的参数，在此方法中可以通过调用publishProgress方法来更新任务的进度，publishProgress方法会调用onProgressUpdate方法。此方法需要返回结果给onPostExecute方法。</p>
<p>​    3.onProgressUpdate(Progress…values)：在主线程中执行，当后台任务的执行进度发生改变时，此方法会被调用。</p>
<p>​    4.onPostExecute(Result result)：在主线程中执行，在异步任务执行之后，此方法会被调用。</p>
<p>​    此外，还提供了一个onCancelled()方法，在主线程中执行，当异步任务被取消时，该方法会被调用。</p>
<h5 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h5><p>​    它继承了Thread，是一种可以使用Handler的Thread，它的实现就是在run方法中，通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环。</p>
<h5 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h5><p>​    它是一种特许的service，它是一个抽象类且继承于Service，因此，必须创建它的子类才能使用它。它可用于执行后台耗时的任务，当任务执行后它会自动停止。</p>
<p>​    因为它是服务的原因，所以它的优先级比单纯的线程要高，所以比较适合执行一些高优先级的后台任务，且不容易被系统杀死。</p>
<h4 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h4><p>​    线程池的优点有：</p>
<ul>
<li>重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。</li>
<li>能有效控制线程池的最大并发数，避免因为大量的线程之间因互相抢占系统资源而导致阻塞现象。</li>
<li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ul>
<h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>​    Android中的线程池都是直接或间接通过配置ThreadPoolExecutor来实现的。</p>
<p>​    它的常用构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="corePoolSize-线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut-属性设置为true，闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔有keepAliveTime指定，当超过该时间后，核心线程会被终止。"><a href="#corePoolSize-线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut-属性设置为true，闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔有keepAliveTime指定，当超过该时间后，核心线程会被终止。" class="headerlink" title="corePoolSize:线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut()属性设置为true，闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔有keepAliveTime指定，当超过该时间后，核心线程会被终止。"></a>corePoolSize:线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut()属性设置为true，闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔有keepAliveTime指定，当超过该时间后，核心线程会被终止。</h5><h5 id="maximumPoolSize-线程池所能容纳的最大线程数，当活动线程数达到这个数目后，后续的新任务会被阻塞。"><a href="#maximumPoolSize-线程池所能容纳的最大线程数，当活动线程数达到这个数目后，后续的新任务会被阻塞。" class="headerlink" title="maximumPoolSize:线程池所能容纳的最大线程数，当活动线程数达到这个数目后，后续的新任务会被阻塞。"></a>maximumPoolSize:线程池所能容纳的最大线程数，当活动线程数达到这个数目后，后续的新任务会被阻塞。</h5><h5 id="keepAliveTime-非核心线程闲置时的超时时长，超过该时长后，非核心线程会被回收。"><a href="#keepAliveTime-非核心线程闲置时的超时时长，超过该时长后，非核心线程会被回收。" class="headerlink" title="keepAliveTime:非核心线程闲置时的超时时长，超过该时长后，非核心线程会被回收。"></a>keepAliveTime:非核心线程闲置时的超时时长，超过该时长后，非核心线程会被回收。</h5><h5 id="unit：用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit-MILLISECONDS-毫秒-，TimeUnit-SECONDS-秒-，TimeUnit-MINUTES（分钟）。"><a href="#unit：用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit-MILLISECONDS-毫秒-，TimeUnit-SECONDS-秒-，TimeUnit-MINUTES（分钟）。" class="headerlink" title="unit：用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit.MILLISECONDS(毫秒)，TimeUnit.SECONDS(秒)，TimeUnit.MINUTES（分钟）。"></a>unit：用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit.MILLISECONDS(毫秒)，TimeUnit.SECONDS(秒)，TimeUnit.MINUTES（分钟）。</h5><h5 id="workQueue-线程池中的任务队列，通过线程池的execute方法提供的Runnable对象会存储在这个参数中。"><a href="#workQueue-线程池中的任务队列，通过线程池的execute方法提供的Runnable对象会存储在这个参数中。" class="headerlink" title="workQueue:线程池中的任务队列，通过线程池的execute方法提供的Runnable对象会存储在这个参数中。"></a>workQueue:线程池中的任务队列，通过线程池的execute方法提供的Runnable对象会存储在这个参数中。</h5><h5 id="theradFactory：线程工厂，为线程池提供创建新线程的功能。它是一个接口，只有一个方法，Thread-newThread-Runnable-r-。"><a href="#theradFactory：线程工厂，为线程池提供创建新线程的功能。它是一个接口，只有一个方法，Thread-newThread-Runnable-r-。" class="headerlink" title="theradFactory：线程工厂，为线程池提供创建新线程的功能。它是一个接口，只有一个方法，Thread newThread(Runnable r)。"></a>theradFactory：线程工厂，为线程池提供创建新线程的功能。它是一个接口，只有一个方法，Thread newThread(Runnable r)。</h5><p>​    除了这些主要的参数外，threadPoolExecutor还提供了一个不常用的参数RejectedExecutionHandler handler。当线程池无法执行新任务的时候，threaddPoolExecutor会调用handler的rejectedExecution方法来通知调用者。</p>
<h4 id="ThreadPoolExecutor执行任务时遵循以下规则："><a href="#ThreadPoolExecutor执行任务时遵循以下规则：" class="headerlink" title="ThreadPoolExecutor执行任务时遵循以下规则："></a>ThreadPoolExecutor执行任务时遵循以下规则：</h4><ul>
<li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li>
<li>如果线程池中的线程数量已经达到或者超过了核心线程数，那么任务会被参入到任务队列中排队等待执行。</li>
<li>如果在上面的步骤中无法将任务插入到任务队列中，一般是因为任务队列已满，这时，如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li>
<li>如果上述步骤中，已经到达线程池中的最大值，会调用RejectedExecutionHandle的rejectedExecution方法通知调用者。</li>
</ul>
<h4 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h4><ul>
<li>FixedThreadPool：通过Executors的newFixedThreadPool方法来创建。是一种线程数量固定的线程池，当线程处于空闲时，它们并不会被回收，除非线程池被关闭。由于它只有核心线程并且这些核心线程不会被回收，所以它能够更加快速的响应外界的请求。实现如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<ul>
<li>CachedThreadPool：通过Executors的newCachedThreadPool方法来创建。它是一种线程数量不定的线程池。它只有非核心线程，其最大的核心线程数为Integer.MAX_VALUE。它的任务队列相当于一个空集合，所以任何的任务都会被立刻执行。</li>
<li>ScheduledThreadPool：通过Executors的newScheduledThreadPool方法来创建。它的核心线程数是固定的，但非核心线程没有限制，并且当非核心线程闲置时会被立即回收，这类的线程池主要用于执行定时任务和具有固定周期的重复任务。</li>
<li>SingleThreadExecutor：通过Executors的newSingleThreadExecutor方法来创建。这类线程池只有一个核心线程，它确保所有的任务都在同一个线程中按顺序执行。它的意义在于统一所有的外界任务到一个线程中，使得这些任务之间不用处理线程同步的问题。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android之ViewPager的使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/08/Android之ViewPager的使用/" class="article-date">
  	<time datetime="2018-06-08T13:53:01.047Z" itemprop="datePublished">2018-06-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/08/Android之ViewPager的使用/">
        Android之ViewPager的使用
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    ViewPager类需要一个适配器为其提供数据，一般与Fragment合用，需要用到FragmentPagerAdapter和FragmentStatePagerAdapter。</p>
<h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><p>​    通过继承PagerAdapter，实现自己的适配器，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPagerAdapter</span> <span class="title">extend</span> <span class="title">PagerAdapter</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;View&gt; mList;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPagerAdapter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写以下方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回页面个数</span></span><br><span class="line">        <span class="keyword">return</span> mList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewFromObject</span><span class="params">(View view,Object object)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> view == object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container,<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        contaner.add(mList.get(position));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container,<span class="keyword">int</span> position,Object object)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        container.removeView((View) object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若界面是fragment，即继承自FragmentPagerAdapter，重写方法即可，与PagerAdapter类似。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：在activity中使用时，构造器中传入getSupportFragment()即可，在Fragment中嵌套使用的话，</span></span><br><span class="line"><span class="comment">//即需要传入getChildFragmentManager()，否则会出现显示未空白的bug。</span></span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>​    在ViewPager中，可以用notifyDataSetChanged()方法对数据进行更新。在PagerAdapter的刷新过程中，每次都会调用notifyDataSetChanged()时，都会调用getItemPostion(Object object)方法，该方法会遍历所有的Item，并且为每一个Item返回一个状态值（POSITION_NONE/POSITION_UNCHANGED），如果返回值为第一个，那么Item会被destroyItem方法移除，然后重新加载，如果是第二个，则不会重新加载，默认情况下应该返回第二个。</p>
<p>​    若需要在ViewPager中更新数据，则需要重写getItemPosition(Object object)方法。</p>
<h4 id="实现更新的方法"><a href="#实现更新的方法" class="headerlink" title="实现更新的方法"></a>实现更新的方法</h4><ol>
<li>直接将<code>getItemPosition(Object object)</code> 的返回值设置为默认的POSITION_UNCHANGE 更改为POSITION_NONE。（这样就会遍历所有的Item，并且destory 所有的item，并且更新全部）。</li>
<li>在PagerAdapter 定义int 型全局变量（意味着需要更新的Item Positon），然后在Adapter中新增函数<code>refresh()</code>，<code>在refresh()</code>函数中首先更新定义的int型全局变量，指明需要更新的item，然后在<code>getItemPosition(Ojbect object)</code> 获取遍历到object Position与需要更新的Item 位置进行比较（利用函数getItemPositon(object)），如果相同的话，返回POSITAION_NONE，这样就可以实现对特定位置的Item进行更新。</li>
</ol>
<h4 id="指示器"><a href="#指示器" class="headerlink" title="指示器"></a>指示器</h4><p>​    可以使用TabLayout，为ViewPager加入指示器，然后调用tabLayout的setupWithViewPager(viewPager)方法设置即可。</p>
<h4 id="实现轮播图"><a href="#实现轮播图" class="headerlink" title="实现轮播图"></a>实现轮播图</h4><p>​    可利用Timer和TimerTask实现定时更新ViewPager的页面。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Java知识点（二）：初始化与清理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/08/Java知识点（二）：初始化与清理/" class="article-date">
  	<time datetime="2018-06-08T09:15:53.316Z" itemprop="datePublished">2018-06-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/08/Java知识点（二）：初始化与清理/">
        Java知识点（二）：初始化与清理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    初始化是指，在使用某个类对象时，必须将用到的数据初始化，不然在调用时，会报错；清理，即在对象使用完时，必须对其进行清理和回收，不然会导致内存耗光。</p>
<h4 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h4><p>​    构造器采用与类相同的名称，可在该方法中进行一些必要参数的初始化，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    在创建对象时，会为对象分配内存空间，并调用相应的构造器，这样就确保了在能操作对象之前，它已经被恰当地初始化了。</p>
<p>​    如果没有指定构造器，编译器会自动创建一个无参的默认构造器。我们可以指定一些有参的构造器，去完成我们想要的初始化工作。</p>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>​    方法名相同，但参数类型或顺序不同的方法，成为方法重载。</p>
<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>​    </p>
<h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>​    this关键字代表引用当前类中的成员变量或方法。</p>
<h4 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h4><p>​    Java提供有垃圾回收机制，垃圾回收器会回收程序不再使用的内存。</p>
<h4 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>...num)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法代表可传入任意int型的参数</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android之Window与WindowManager" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/08/Android之Window与WindowManager/" class="article-date">
  	<time datetime="2018-06-08T08:41:16.935Z" itemprop="datePublished">2018-06-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/08/Android之Window与WindowManager/">
        Android之Window与WindowManager
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>​    在Android中，window表示一个窗口的概念，在我们需要在桌面上显示一个类似于悬浮窗的效果时，就需要用到window来实现。</p>
<p>​    window是一个抽象类，它的具体实现是phoneWindow。创建一个window，只需要通过windowManager即可完成；windowMnager是外界访问window的入口，window的具体实现位于，windowMangerService中，windowMangerService与windowManager的交互是一个ipc过程。Android中的所有视图都是通过window来呈现的，包括activity、dialog、toast，它们的视图实际上都是附加在window上，因此，window实际是view的管理者。</p>
<p>​    通过windowMnager添加一个window的过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mButton = <span class="keyword">new</span> Button(<span class="keyword">this</span>);</span><br><span class="line">mButton.setText(<span class="string">"button"</span>);</span><br><span class="line">mLp = <span class="keyword">new</span> WindowManager.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT,</span><br><span class="line">                                    <span class="number">0</span>,<span class="number">0</span>,PixelFormat.TRANSPARENT);</span><br><span class="line">mLp.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL</span><br><span class="line">|LayoutParams.FLAG_NOT_FOCUSABLE|LayoutParams.FLAG_SHOW_WHEN_LOCKED；</span><br><span class="line">mLp.gravity = Gravity.LEFT |Gravity.TOP;</span><br><span class="line">mLp.x = <span class="number">100</span>;</span><br><span class="line">mLp.y = <span class="number">300</span>;</span><br><span class="line">mWindowMnager.addView(mButton,mLp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上为添加一个button到屏幕坐标为（100，300）的位置上。</span></span><br><span class="line"><span class="comment">//其中，Flags参数表示window的属性，具体属性意义查看文档。</span></span><br></pre></td></tr></table></figure>
<h4 id="Window的类型"><a href="#Window的类型" class="headerlink" title="Window的类型"></a>Window的类型</h4><p>​    window的类型有三种，分别为应用window，对应一个acitivity、子window（不能单独存在，需要附属在特定的父window中，如Dialog就是一个子window）、系统window（需要声明权限才能创建的window，如Toast和系统状态栏）。</p>
<p>​    window是分层的，每个window都有对应的z-ordered，层级大的会覆盖在层级小的window上面；其中应用window的层级范围是1~99，子window的层级范围为1000~1999，系统window的范围为2000~2999，这些层级范围对应着windowManager.LayoutParams的type参数。</p>
<p>​    在使用系统window时，需声明权限：</p>
<p>&lt;uses-permission android:name=”android.permission.SYSTEM_ALERT_WINDOW”/</p>
<p>不然会报错。</p>
<h3 id="WindowManger的功能"><a href="#WindowManger的功能" class="headerlink" title="WindowManger的功能"></a>WindowManger的功能</h3><p>​    常用的三个方法为，添加view：addView()、更新view：updateView()、删除view：removeView()。</p>
<h3 id="Window的内部机制"><a href="#Window的内部机制" class="headerlink" title="Window的内部机制"></a>Window的内部机制</h3><p>​    每一个window都对应着一个View和一个ViewRootImpl，window与view通过ViewRootImpl建立联系。</p>
<h4 id="window的添加过程"><a href="#window的添加过程" class="headerlink" title="window的添加过程"></a>window的添加过程</h4><p>​    通过windowManager的addView来实现，windowManager是一个接口，它的实现类为WindowManagerImpl。</p>
<p>​    查看该类的源码可知，它的三大操作时交由windowManagerGlobal来处理的，它时以工厂的形式向外提供自己的实例。它的addView方法主要分为以下几步：</p>
<h5 id="1-检查参数是否合法，如果是子window的话还需要调整一些布局参数"><a href="#1-检查参数是否合法，如果是子window的话还需要调整一些布局参数" class="headerlink" title="1.检查参数是否合法，如果是子window的话还需要调整一些布局参数"></a>1.检查参数是否合法，如果是子window的话还需要调整一些布局参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(view == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//throw some exception</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(display == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//throw some exception</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams))&#123;</span><br><span class="line">    <span class="comment">//throw some exception</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> WindowManager.LayoutParams wParams = (WindowManager.LayoutParams) params;</span><br><span class="line"><span class="keyword">if</span>(parentWindow != <span class="keyword">null</span>)&#123;</span><br><span class="line">    parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-创建ViewRootImpl并将View添加到列表中"><a href="#2-创建ViewRootImpl并将View添加到列表中" class="headerlink" title="2.创建ViewRootImpl并将View添加到列表中"></a>2.创建ViewRootImpl并将View添加到列表中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="keyword">new</span> ViewRoootImpl(view.getContext(),display);</span><br><span class="line">view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下列表均为WindowManagerGlobal中的参数</span></span><br><span class="line">mViews.add(view);</span><br><span class="line">mRoots.add(root);</span><br><span class="line">mParams.add(wparams);</span><br></pre></td></tr></table></figure>
<h5 id="3-通过ViewRootImpl来更新界面并完成添加过程"><a href="#3-通过ViewRootImpl来更新界面并完成添加过程" class="headerlink" title="3.通过ViewRootImpl来更新界面并完成添加过程"></a>3.通过ViewRootImpl来更新界面并完成添加过程</h5><p>​    该过程由ViewRootImpl的setView()方法完成，该方法内部通过requestLayout()来完成异步刷新请求。</p>
<p>另外两个过程原理类似，暂时省略，查看源码可了解。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Java知识点（一）：对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/07/Java知识点（一）：对象/" class="article-date">
  	<time datetime="2018-06-07T14:22:08.308Z" itemprop="datePublished">2018-06-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/07/Java知识点（一）：对象/">
        Java知识点（一）：对象
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    在JAVA中，所有的东西都会被视为对象，通过对象的引用来操作对象。</p>
<h4 id="存储分类"><a href="#存储分类" class="headerlink" title="存储分类"></a>存储分类</h4><ul>
<li>寄存器：最快的存储区，位于处理器内部，但是它的数量有限，所以会根据需要进行分配。</li>
<li>堆栈：位于RAM（随机访问存储器）中，可通过堆栈指针从处理器中获得直接支持。堆栈指针向下移动则分配新的内存，向上移动则释放内存。创建程序时，JAVA系统必须知道存储在堆栈内的所有项的确切生命周期，以便上下移动堆栈指针；对象引用位于堆栈，但对象并不存储在这。</li>
<li>堆：通用的内存池，位于RAM。用于存放所有的Java对象。</li>
<li>常量存储：常量值通常直接存放在程序代码内部；有时，在嵌入式系统中，常量本身会和其他部分分隔开，在这种情况下，可以选择将其放在ROM（只读内存器）中。</li>
<li>非RAM：</li>
</ul>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>​    java中的基本类型有：</p>
<ul>
<li><p>boolean：它的包装类型为Boolean，取值只能为true or false</p>
</li>
<li><p>char：16bit大小，包装类型为Character</p>
</li>
<li><p>byte：8bits，包装类型为Byte</p>
</li>
<li><p>short：16bits，包装类型为Short</p>
</li>
<li><p>int：32 bits，包装类型为Integer</p>
</li>
<li><p>long：64bits，包装类型为Long</p>
</li>
<li><p>float：32bits，包装类型为Float</p>
</li>
<li><p>double：64bits，包装类型为Double</p>
<p>除此之外，Java提供了用于高精度计算的类：BigInteger和BigDecimal，提供的操作与基本类型的类似。</p>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>​    在java中，数组会确保被初始化，而且不能在它的范围外被访问，因为在运行时会进行下标检查，有一定的代价。</p>
<p>​    当创建一个数组时，实际上是创建了一个引用数组，并且每个引用都会自动被初始化为一个特定值。</p>
<h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><p>​    一般来说，对象都是在new之后才分配存储空间，然后才可以被调用。但是，有时候想在没有创建对象时，也能调用对象中的方法，这时候就可以利用static关键字了。当某个事物被声明为static，即表明这个事物，不会与包含它的类的任何对象实例关联在一起，直接可以通过类名调用。</p>
<p>​    被static生命的对象，在全局中只有一份存储空间，且它的生命周期与程序一样。</p>
<p>​    在static方法中，不能调用非static的事物。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-EventBus的基本使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/07/EventBus的基本使用/" class="article-date">
  	<time datetime="2018-06-07T12:50:53.848Z" itemprop="datePublished">2018-06-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/07/EventBus的基本使用/">
        EventBus的基本使用
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.添加依赖 在github上面看eventbus的最新版本,在app的build.gradle文件中导入</p>
<p>2.定义事件:<br>    事件(Event) 是没有任何特殊要求的 POJO(类似于bean类),如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventData</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">EventData</span><span class="params">()</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>3.在Activity的onCreate()方法中注册 或Fragment中的onCreateView()方法中注册<br>一般情况下调用它的默认方法，注册即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>​    同时,需要在activity 的onDestroy()或Fragment中的onDestroy()方法中销毁，<br>同样，一般情况下调用其默认方法即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>4.准备Subscriber（订阅者）<br>    Subscriber 方法使用 @subscribe 注解定义，实现了事件处理方法。(在EventBus3中，方法名可以自由定义)<br>如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该注解下的方法运行在主线程，即UI线程中。</span></span><br><span class="line">	<span class="meta">@Subscribe</span>(threadMode = TreadMode.MAIN)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventData</span><span class="params">(EventData eventData)</span></span>&#123;</span><br><span class="line">		<span class="comment">//logic...</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​    在EventBus中会帮我们处理好线程的问题。以上的注解为运行在主线程中，<br>所有的注解定义如下：</p>
<p>​    1.ThreadMode.POSTING（默认）<br>        Subscriber 方法会在发布该事件的同一线程被调用。事件发送之后，所有的Subscriber方法都会被调用,<br>    由于没有切换线程，所以开销会比较小。使用这种模式的事件回调应该迅速返回以防阻塞发送事件的线程（可能是主线程）。</p>
<p>​    2.ThreadMode.MAIN<br>        该注解下的方法会运行在主线程中，如果发送事件的线程是主线程的话，会直接调用 Subscriber 方法（同步调用，表现同 ThreadMode.POSTING）。<br>        使用这种模式的事件回调必须迅速返回以防阻塞发送事件的线程。</p>
<p>​    3.ThreadMode.MAIN_ORDERED<br>        该注解下的方法同样会运行在主线程中，事件总是排队等待以传递给 Subscriber。<br>        该模式保证了事件处理有一个更严格一致的顺序。<br>        使用这种模式的事件回调必须迅速返回以防阻塞发送事件的线程</p>
<p>​    4.ThreadMode.BACKGROUND<br>        该注解下的方法会运行在后台线程中。如果发布事件的线程不是主线程，事件回调将直接在发布线程被                调用。否则，EventBus 使用一个后台线程（单例）来按序调用每个回调。使用这种模式的事件回调应该尝试快速返回以尽量不要阻塞后台线程</p>
<p>​    5.ThreadMode.ASYNC<br>        事件回调方法总是在单独的线程被调用。<br>        这些线程不会是发布事件的线程，也不会是主线程。向此模式的回调方法 post 事件永远不会发生等待。<br>        如果回调方法执行网络请求之类的耗时操作的话则应该使用这种模式，<br>        避免同时触发大量长时间运行的异步任务来限制并发线程的数量，EventBus 使用线程池有效地重用已完    成的异步任务线程。</p>
<p>5.发布事件 </p>
<p>​    所有已注册并且匹配该类型的 Subscriber（订阅者）都会收到该事件：在代码的任何地方中均可调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventData ed = <span class="keyword">new</span> EventData();</span><br><span class="line">	ed.setName(<span class="string">"zzp"</span>);</span><br><span class="line">	EventBus.getDefault().post(ed);</span><br></pre></td></tr></table></figure>
<p>通过以上几个步骤就可以简单地使用EventBus了。</p>
<p>6.Sticky Events (粘性事件)</p>
<p>​    对于某些事件，在其被 post 之后我们仍然关心它携带的信息,想要保存最近一次的值;    对此，可以使用Sticky Events,EventBus 会将最后一个特定类型的粘性事件保存在内存中，这个粘性事件可以传递给 Subscriber 或者被直接查询。</p>
<p>​    调用postSticky()方法发送粘性事件<br>    EventBus.getDefault().postSticky(new EventData(“zzp”));</p>
<p>在注解中加入 sticky = true，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(sticky = <span class="keyword">true</span>, threadMode = ThreadMode.MAIN)</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(EventData ea)</span> </span>&#123;   </span><br><span class="line"></span><br><span class="line">		<span class="comment">//log..</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这样，所有订阅粘性时间的方法在注册的时候就会立即收到之前 post 的粘性事件。</p>
<p>7.手动获取/移除粘性事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取:</span></span><br><span class="line">EventData ed = EventBus.getDefault().getStickyEvent(EventData.class);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//移除:</span></span><br><span class="line"><span class="keyword">if</span>(ed != <span class="keyword">null</span>) EventBus.getDefault().removeStickyEvent(ed);</span><br></pre></td></tr></table></figure>
<p>8.优先级和事件的取消</p>
<p>​    优先级只影响相同 ThreadMode 中的 Subscriber。</p>
<p>​    在注解中设置优先级:<br>    @Subscribe(priority = 1);</p>
<p>取消事件的传递：<br>        在 Subscriber 的事件处理线程调用 cancelEventDelivery(Object event)<br>        来取消事件传递. 进一步的事件传递将被取消，接下来的 Subscriber 都不会接收到事件<br>        事件取消仅限于用在 ThreadMode.PostThread 模式下的事件处理方法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Rxjava的使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/07/Rxjava的使用/" class="article-date">
  	<time datetime="2018-06-07T12:40:23.805Z" itemprop="datePublished">2018-06-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/07/Rxjava的使用/">
        Rxjava的使用
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.创建被观察者对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;()&#123;</span><br><span class="line">	 <span class="comment">// create() 是 RxJava 最基本的创造事件序列的方法</span></span><br><span class="line">	 <span class="comment">// 此处传入了一个 OnSubscribe 对象参数</span></span><br><span class="line">	 <span class="comment">// 当 Observable 被订阅时，OnSubscribe 的 call() 方法会自动被调用，即事件序列就会依照设定依次被触发</span></span><br><span class="line">	 <span class="comment">// 即观察者会依次调用对应事件的复写方法从而响应事件</span></span><br><span class="line">	 <span class="comment">// 从而实现被观察者调用了观察者的回调方法 &amp; 由被观察者向观察者的事件传递，即观察者模式</span></span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 2. 在复写的subscribe（）里定义需要发送的事件</span></span><br><span class="line">	 </span><br><span class="line">	 <span class="meta">@Override</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		 <span class="comment">// 通过 ObservableEmitter类对象产生事件并通知观察者</span></span><br><span class="line">		 <span class="comment">// ObservableEmitter类介绍</span></span><br><span class="line">           <span class="comment">// a. 定义：事件发射器</span></span><br><span class="line">           <span class="comment">// b. 作用：定义需要发送的事件 &amp; 向观察者发送事件</span></span><br><span class="line">		   emitter.next(<span class="number">1</span>);</span><br><span class="line">		   emitter.next(<span class="number">2</span>);</span><br><span class="line">		   emitter.next(<span class="number">3</span>);</span><br><span class="line">		   emitter.onComplete();</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">-扩展：RxJava 提供了其他方法用于 创建被观察者对象Observable --&gt;</span></span><br><span class="line"><span class="comment">	方法1：just(T...)：直接将传入的参数依次发送出来</span></span><br><span class="line"><span class="comment">  Observable observable = Observable.just("A", "B", "C");</span></span><br><span class="line"><span class="comment">  // 将会依次调用：</span></span><br><span class="line"><span class="comment">	onNext("A");</span></span><br><span class="line"><span class="comment">	onNext("B");</span></span><br><span class="line"><span class="comment">	onNext("C");</span></span><br><span class="line"><span class="comment">	onCompleted();</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	方法2：from(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组 / Iterable 拆分成具体对象后，依次发送出来</span></span><br><span class="line"><span class="comment">	String[] words = &#123;"A", "B", "C"&#125;;</span></span><br><span class="line"><span class="comment">	Observable observable = Observable.from(words);</span></span><br><span class="line"><span class="comment">	// 将会依次调用：</span></span><br><span class="line"><span class="comment">	onNext("A");</span></span><br><span class="line"><span class="comment">	onNext("B");</span></span><br><span class="line"><span class="comment">	onNext("C");</span></span><br><span class="line"><span class="comment">	onCompleted();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>2.创建观察者并定义响应事件的行为</p>
<p>​    发生的事件类型包括：<br>  Next事件:普通事件，向观察者发送需要响应事件的信号，被观察者可以发送无限个next信号，观察者可以接受无限个next信号,调用onNext()方法使用;</p>
<p>  Complete事件:事件队列完结事件，该事件标志着被观察者不再发送普通事件，当被观察者发送一个Complete事件后，<br>    被观察者在Complete事件后的事件将会继续发送，但观察者收到Complete事件后，将不再继续接受任何事件（被观察者可以不发送Complete事件）,Complete事件调用onComplete()方法使用；</p>
<p>  Error事件：事件队列异常事件，该事件标志着事件处理过程中出现异常（此时队列自动终止，不允许再有事件发出），当被观察者发送出一个Error事件后，<br>    被观察者在Error事件后的事件将继续发送，但观察者收到Error事件后将不再接受任何事件（被观察者可以不发送Error事件）,调用onError()方法发送该事件。<br>    注意：在一个正确运行的事件序列中：Complete事件与Error事件互斥，只能有一个</p>
<p>​    具体实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：采用Observer接口</span></span><br><span class="line">		<span class="comment">//创建观察者对象</span></span><br><span class="line">		Observer&lt;Integer&gt; observer = <span class="keyword">new</span> Observer&lt;Integer&gt;()&#123;</span><br><span class="line">			<span class="comment">// 2. 创建对象时通过对应复写对应事件方法 从而 响应对应事件</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 观察者接收事件前，默认最先调用复写 onSubscribe（）</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span></span>&#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当被观察者生产Next事件 &amp; 观察者接收到时，会调用该复写方法 进行响应</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Next事件作出响应"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 当被观察者生产Error事件&amp; 观察者接收到时，会调用该复写方法 进行响应</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当被观察者生产Complete事件&amp; 观察者接收到时，会调用该复写方法 进行响应</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 方法2：采用Subscriber 抽象类 :Subscriber类 = RxJava 内置的一个实现了 Observer 的抽象类，对 Observer 接口进行了扩展</span></span><br><span class="line">	Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 创建对象时通过对应复写对应事件方法 从而 响应对应事件</span></span><br><span class="line">            <span class="comment">// 观察者接收事件前，默认最先调用复写 onSubscribe（）</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当被观察者生产Next事件 &amp; 观察者接收到时，会调用该复写方法 进行响应</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Next事件作出响应"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当被观察者生产Error事件&amp; 观察者接收到时，会调用该复写方法 进行响应</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当被观察者生产Complete事件&amp; 观察者接收到时，会调用该复写方法 进行响应</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		二者基本使用方式完全一致（实质上，在RxJava的 subscribe 过程中，Observer总是会先被转换成Subscriber再使用） </span></span><br><span class="line"><span class="comment">		不同在于：</span></span><br><span class="line"><span class="comment">			Subscriber抽象类对 Observer 接口进行了扩展，新增了两个方法：</span></span><br><span class="line"><span class="comment">			1. onStart()：在还未响应事件前调用，用于做一些初始化工作</span></span><br><span class="line"><span class="comment">			2. unsubscribe()：用于取消订阅。在该方法被调用后，观察者将不再接收 &amp; 响应事件</span></span><br><span class="line"><span class="comment">				调用该方法前，先使用 isUnsubscribed() 判断状态，确定被观察者Observable是否还持有观察者Subscriber的引用，</span></span><br><span class="line"><span class="comment">				如果引用不能及时释放，就会出现内存泄露</span></span><br><span class="line"><span class="comment">		*/</span></span><br></pre></td></tr></table></figure>
<p>3.通过Subscribe订阅链接两者<br>    实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	以上方法的内部实现为：</span></span><br><span class="line"><span class="comment">		public Subscription subscribe(Subscriber subscriber) &#123;</span></span><br><span class="line"><span class="comment">    subscriber.onStart();</span></span><br><span class="line"><span class="comment">    // 步骤1中 观察者  subscriber抽象类复写的方法，用于初始化工作</span></span><br><span class="line"><span class="comment">    onSubscribe.call(subscriber);</span></span><br><span class="line"><span class="comment">    // 通过该调用，从而回调观察者中的对应方法从而响应被观察者生产的事件</span></span><br><span class="line"><span class="comment">    // 从而实现被观察者调用了观察者的回调方法 &amp; 由被观察者向观察者的事件传递，即观察者模式</span></span><br><span class="line"><span class="comment">    // 同时也看出：Observable只是生产事件，真正的发送事件是在它被订阅的时候，即当 subscribe() 方法执行时</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br></pre></td></tr></table></figure>
<p>4.整体链式调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;()&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">			emitter.onNext(<span class="number">1</span>);</span><br><span class="line">			emitter.onNext(<span class="number">2</span>);</span><br><span class="line">			emitter.onNext(<span class="number">3</span>);</span><br><span class="line">			emitter.onComplete();</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;()&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span></span>&#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span></span>&#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android之View动画分析与记录" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/07/Android之View动画分析与记录/" class="article-date">
  	<time datetime="2018-06-07T08:58:12.927Z" itemprop="datePublished">2018-06-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/07/Android之View动画分析与记录/">
        Android之View动画分析与记录
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="动画分类"><a href="#动画分类" class="headerlink" title="动画分类"></a>动画分类</h3><p>​    android动画可分为：View动画、帧动画、属性动画。</p>
<h4 id="View动画"><a href="#View动画" class="headerlink" title="View动画"></a>View动画</h4><p>​    view动画的作用对象是view，支持4种动画效果，分别为：平移动画TranslateAnimation、缩放动画ScaleAnimation、旋转动画RotateAnimation、透明度动画AlphaAnimation。</p>
<p>​    view动画一般是使用xml文件定义，可以是单个动画，也可以是一系列的动画组合，该文件放在 res/anim/文件目录下（没有anim则新建）。</p>
<p>​    4种动画在xml文件中对应得标签为<translate>、<scale>、<rotate>、<alpha>。</alpha></rotate></scale></translate></p>
<p>​    xml文件一般如下定义:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"...."</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:interpolator</span>=<span class="string">"@[package:]anim/interpolator_resource"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:shareInterpolator</span>=<span class="string">[</span>"<span class="attr">true</span>"|"<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">     &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:fromAlpha</span>=<span class="string">"float"</span> //开始透明度</span></span><br><span class="line"><span class="tag">           <span class="attr">android:toAlpha</span>=<span class="string">"float"</span>  //结束透明度</span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scale</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:fromXScale</span>=<span class="string">"float"</span> //<span class="attr">x</span>轴上的起始缩放度</span></span><br><span class="line"><span class="tag">           <span class="attr">android:toXScale</span>=<span class="string">"float"</span>  // 结束时的缩放度</span></span><br><span class="line"><span class="tag">           <span class="attr">android:fromYScale</span>=<span class="string">"float"</span> //<span class="attr">Y</span>轴</span></span><br><span class="line"><span class="tag">           <span class="attr">android:toYScale</span>=<span class="string">"float"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">android:pivotX</span>=<span class="string">"float"</span> //缩放<span class="attr">x</span>坐标</span></span><br><span class="line"><span class="tag">           <span class="attr">android:pivotY</span>=<span class="string">"float"</span> //<span class="attr">y</span>坐标</span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:fromXDelta</span>=<span class="string">"float"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:toXDelta</span>=<span class="string">"float"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:fromYDelta</span>=<span class="string">"float"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:toYDelta</span>=<span class="string">"float"</span></span></span><br><span class="line"><span class="tag">               /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rotate</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fromDegrees</span>=<span class="string">"float"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:toDegrees</span>=<span class="string">"float"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pivotX</span>=<span class="string">"float"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pivotY</span>=<span class="string">"float"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    	//另一组动画</span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <set>标签表示是动画集合，对应于AnimationSet类。</set></p>
<p>​    应用如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">View someView = findViewById(R.id.xxx);</span><br><span class="line">Animation animation = AnimationUtils.loadAnimation(<span class="keyword">this</span>,R.anim.animation_source);</span><br><span class="line">someView.startAnimation(animation);</span><br></pre></td></tr></table></figure>
<p>​    除了在xml中定义外，还可以通过代码定义，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    监听动画过程，可以为view动画添加AnimationListener监听动画的过程。</p>
<h4 id="自定义View动画"><a href="#自定义View动画" class="headerlink" title="自定义View动画"></a>自定义View动画</h4><p>​    自定义View动画需要继承自Animation抽象类，重写它的initialize()、applyTransformation()方法。</p>
<h3 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h3><p>​    它是顺序播放一组预定义好的图片，使用AnimationDrawable类来使用。</p>
<p>注意，帧动画会比较容易引起OOM，尽量避免使用较大尺寸的图片。</p>
<p>​    首先需要通过xml来定义，帧动画的文件放在res/drawable/目录下</p>
<p>​    </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animation-list</span></span></span><br><span class="line"><span class="tag">                <span class="attr">xmlns:android</span>=<span class="string">"..."</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:oneshot</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"img_source"</span> <span class="attr">android:duration</span>=<span class="string">"300"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">.......</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    然后将该Drawable文件作为View的背景并通过Drawable来播放动画即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">View someView = ...;</span><br><span class="line">someView.setBackgroudResourc(R.drawable.xxx);</span><br><span class="line">AnimationDrawable ad = (AnimationDrawable) someView.getBackgroud();</span><br><span class="line">ad.start();</span><br></pre></td></tr></table></figure>
<h3 id="View动画的使用场景"><a href="#View动画的使用场景" class="headerlink" title="View动画的使用场景"></a>View动画的使用场景</h3><h4 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a>LayoutAnimation</h4><p>​    作用于ViewGroup，为它指定一个动画，当它的子元素出场时都会有这种动画效果。</p>
<p>​    定义如下：( res/anim/xxx)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layoutAnimation</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">xmlns:android</span>=<span class="string">"..."</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:delay</span>=<span class="string">"0.5"</span> //表示子元素的开始动画时间延迟，如动画持续时间是<span class="attr">1</span>秒，</span></span><br><span class="line"><span class="tag">                 //则<span class="attr">0.5</span>*<span class="attr">1000</span>=<span class="string">500，延迟500ms</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animationOrder</span>=<span class="string">"normal"</span> //表示子元素的动画顺序</span></span><br><span class="line"><span class="tag">                 //三种选项：<span class="attr">normal</span>（顺序显示）、<span class="attr">reverse</span>（逆向显示）、<span class="attr">random</span>（随机显示）</span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animation</span>=<span class="string">"@anim/xxx"</span> //为子元素指定具体的入场动画</span></span><br><span class="line"><span class="tag">                 &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">layoutAnimation</span>&gt;</span></span><br><span class="line">//同样的，该效果在代码中可通过LayoutAnimationController实现</span><br></pre></td></tr></table></figure>
<p>​    然后为ViewGroup指定android:layoutAnimation属性，adnroid:layoutAnimation=”@anim/layoutAnimation_source”</p>
<h4 id="Activity的切换效果"><a href="#Activity的切换效果" class="headerlink" title="Activity的切换效果"></a>Activity的切换效果</h4><p>​    主要用overridePendingTransition(int enterAnim,int exitAnim)方法，该方法必须在startActivity()或finish()后调用才生效。</p>
<h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>​    属性动画可以对任意对象的属性进行动画。动画默认时间间隔为300ms，默认帧率为10帧每秒，在一个时间间隔内完成对象从一个属性到另一个属性的转换。（但是属性动画从API11以上才引入）</p>
<p>​    使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(viewObject,<span class="string">"translationY"</span>,delta).start();</span><br><span class="line"><span class="comment">//该效果为在Y轴上平移delta的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动画集合</span></span><br><span class="line">AnimationSet set = <span class="keyword">new</span> AnimationSet();</span><br><span class="line">set.playTogether(</span><br><span class="line">	ObjectAnimator.ofFloat(targetView,<span class="string">"rotationX"</span>,<span class="number">0</span>,<span class="number">360</span>),</span><br><span class="line">    ObjectAnimator.ofFloat(...),</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line">    set.setDuration(<span class="number">3000</span>).start();</span><br></pre></td></tr></table></figure>
<p>​    在xml中的定义如下：（res/animator目录下，animator目录没有则创建）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:ordering</span>=<span class="string">[</span>"<span class="attr">together</span>"|"<span class="attr">sequentially</span>"]&gt;</span> //指定动画播放顺序，togetther代表同时播放，</span><br><span class="line">    //另一个为顺序播放</span><br><span class="line"><span class="tag">&lt;<span class="name">obejceAnimator</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:propertyName</span>=<span class="string">"string"</span> //属性名称</span></span><br><span class="line"><span class="tag">                <span class="attr">android:duration</span>=<span class="string">"int"</span> //时长</span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueFrom</span>=<span class="string">"float|int|color"</span> //属性起始值</span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueTo</span>=<span class="string">"float|int|color"</span>  //结束值</span></span><br><span class="line"><span class="tag">                <span class="attr">android:startOffset</span>=<span class="string">"int"</span> //动画的延迟时间</span></span><br><span class="line"><span class="tag">                <span class="attr">android:repeatCount</span>=<span class="string">"int"</span> //重复次数 默认为<span class="attr">0</span>，<span class="attr">-1</span>代表无限循环</span></span><br><span class="line"><span class="tag">                <span class="attr">android:repeatMode</span>=<span class="string">[</span>"<span class="attr">restart</span>"|"<span class="attr">reverse</span>"] //重复模式</span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueType</span>=<span class="string">[</span>"<span class="attr">intType</span>"|"<span class="attr">floatType</span>"]</span></span><br><span class="line"><span class="tag">                //表示<span class="attr">android:propertyName</span>所指定的属性类型，有<span class="attr">intType</span>和<span class="attr">floatType</span>可选，</span></span><br><span class="line"><span class="tag">                //但<span class="attr">propertyName</span>指定为颜色的话，则该属性不应指定</span></span><br><span class="line"><span class="tag">                &gt;</span><span class="tag">&lt;/<span class="name">obejceAnimator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animator</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:duration</span>=<span class="string">"int"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:valueFrom</span>=<span class="string">"float|int|color"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:valueTo</span>=<span class="string">"float|int|color"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:startOffset</span>=<span class="string">"int"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:repeatCount</span>=<span class="string">"int"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:repeatMode</span>=<span class="string">[</span>"<span class="attr">restart</span>"|"<span class="attr">reverse</span>"]</span></span><br><span class="line"><span class="tag">              <span class="attr">android:valueType</span>=<span class="string">[</span>"<span class="attr">intType</span>"|"<span class="attr">floatType</span>"]  </span></span><br><span class="line"><span class="tag">              &gt;</span><span class="tag">&lt;/<span class="name">animator</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    	...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    在xml中可以定义ValueAnimator,ObjectAnimator,AnimatorSet，其中，<set>对应AnimatorSet,<animator>对应ValueAnimator，<objectanimator>对应于ObjectAnimator</objectanimator></animator></set></p>
<h4 id="插值器和估值器"><a href="#插值器和估值器" class="headerlink" title="插值器和估值器"></a>插值器和估值器</h4><p>​    TimeInterpolator为时间插值器，它的作用是根据时间流逝的百分比计算出当前属性值改变的百分比。</p>
<p>系统预置的有LinearInterpolator线性插值器（匀速动画）、AccelerateDecelerateInterpolator(加速减速插值器，动画两头慢中间快)、DecelerateInterpolator（减速插值器，动画越来越慢）</p>
<p>​    TypeInterpolator为类型估值器，它的作用是根据当前属性改变的百分比来计算改变后的属性值。系统预置的有IntEvaluator（针对整型属性）、floatEvaluator(针对浮点型)等。</p>
<p>​    我们可以自定义插值器和估值器，需要实现Interpolator或TimeInterpolator（自定义插值器），或实现TypeEvaluator(估值器)</p>
<h4 id="属性动画的监听器"><a href="#属性动画的监听器" class="headerlink" title="属性动画的监听器"></a>属性动画的监听器</h4><p>​    AnimatorUpdateListener和AnimatorListener用于监听动画的播放过程。</p>
<h4 id="对任意属性做动画"><a href="#对任意属性做动画" class="headerlink" title="对任意属性做动画"></a>对任意属性做动画</h4><p>​    属性动画要求动画作用的对象提供该属性的get、set方法，即要想让动画生效，必须满足以下两个条件，</p>
<p>​    1.object必须提供setProperty方法，如果动画的时候没有传递初始值，那么还要提供getProperty方法，因为系统需要获取property属性的初始值。</p>
<p>​    2.object的setProperty对属性所作的改变必须能够通过某种方法放映出来。</p>
<p>​    解决办法1.</p>
<p>用一个类来包装原始对象，间接为其提供get,set方法。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    解决办法2：</p>
<p>采用ValueAnimator，监听动画过程，手动实现属性的改变。ValueAnimator本身不做用于任何对象，它对一个值做动画，然后可以监听其动画过程，在该过程中修改对象的属性值，这样就等于对对象做了动画。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android四大组件之ContentProvider内容提供器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/25/Android四大组件之ContentProvider内容提供器/" class="article-date">
  	<time datetime="2018-04-25T14:14:40.628Z" itemprop="datePublished">2018-04-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/25/Android四大组件之ContentProvider内容提供器/">
        Android四大组件之ContentProvider内容提供器
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>​    ContentProvider主要用于在不同的app之间实现数据共享的功能，允许一个app访问另一个app中的数据，同时保证被访数据的安全；它是实现跨程序共享数据的标准方式。</p>
<h3 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h3><p>​    继承ContentProvider类，实现其抽象方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">OnCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        初始化内容提供器时调用，一般在这里完成数据库的创建与升级等操作</span></span><br><span class="line"><span class="comment">        （只在有调用ContentResolver尝试访问app中的数据时，才会被初始化）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//返回true代表初始化成功，false则为失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri,String[] projection,String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] selectionArgs,String sortOrder)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用该方法从内容提供器中查询数据，uri参数用作确定查询的表</span></span><br><span class="line"><span class="comment">        projection参数用于确定查询的列，selection,selectionArgs是查询的条件</span></span><br><span class="line"><span class="comment">        sortOrder是对结果进行排序</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        查询结果存放在Cursor对象中返回</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri,ContentValues values)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        想内容提供器中插入一条数据</span></span><br><span class="line"><span class="comment">        uri:确定插入的表</span></span><br><span class="line"><span class="comment">        values：插入的数据</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        添加成功后会返回表示该条新数据的uri</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri,ContentValues values,String selection,String[] selectionArgs)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        更新数据时调用该方法</span></span><br><span class="line"><span class="comment">        uri:同理</span></span><br><span class="line"><span class="comment">        values:新的数据</span></span><br><span class="line"><span class="comment">        selection、selectionArgs:更新的条件</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        返回更新了的行数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri,String selection,String[] selectionArgs)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        删除数据时调用</span></span><br><span class="line"><span class="comment">        uri:同理</span></span><br><span class="line"><span class="comment">        selection、selectionArgs：同理</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        返回被删除的行数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用该方法，是根据传入的uri返回相应的MIME类型</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    其中Uri是各个方法中必须的参数，标准的内容URI的写法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">content://com.example.app.provider/table/id</span><br><span class="line">表示的是调用com.example.app应用中table表的数据，id为查询表中 id为此值的数据(不传入此值，则代表查询全表)</span><br><span class="line"></span><br><span class="line">若想查询匹配任意表的内容，则可将table改为 *，如：</span><br><span class="line">content://com.example.app.prodiver/*</span><br><span class="line"></span><br><span class="line">若想查询具体表中的某一行,即可将id替换为#，如：</span><br><span class="line">content://com.eaxmple.app.provider/table/#</span><br></pre></td></tr></table></figure>
<p>​    然后，调用UriMatcher类实现匹配内容URI，调用addURI()方法，则MyProvider可修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TABLE1_DIR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TABLE1_ITEM = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TABLE2_DIR = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TABLE1_ITEM = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UriMatcher uriMatcher;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        uriMatcher = <span class="keyword">new</span> UriMatcher(Uri.Matcher.NO_MATCH);</span><br><span class="line">        <span class="comment">//第一个参数为authority(一般为应用包名.provider)</span></span><br><span class="line">        <span class="comment">//第二个参数为path，即查询的表</span></span><br><span class="line">        <span class="comment">//第三个参数为自定义码</span></span><br><span class="line">        uriMatcher.addUri(<span class="string">"com.example.app.provider"</span>,<span class="string">"table1"</span>,TABLE1_DIR);</span><br><span class="line">        uriMatcher.addUri(<span class="string">"com.example.app.provider"</span>,<span class="string">"table1/#"</span>,TABLE1_ITEM);</span><br><span class="line">        uriMatcher.addUri(<span class="string">"com.example.app.provider"</span>,<span class="string">"table2"</span>,TABLE2_DIR);</span><br><span class="line">        uriMatcher.addUri(<span class="string">"com.example.app.provider"</span>,<span class="string">"table2/#"</span>,TABLE2_ITEM);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">OnCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        初始化内容提供器时调用，一般在这里完成数据库的创建与升级等操作</span></span><br><span class="line"><span class="comment">        （只在有调用ContentResolver尝试访问app中的数据时，才会被初始化）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//返回true代表初始化成功，false则为失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri,String[] projection,String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] selectionArgs,String sortOrder)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用该方法从内容提供器中查询数据，uri参数用作确定查询的表</span></span><br><span class="line"><span class="comment">        projection参数用于确定查询的列，selection,selectionArgs是查询的条件</span></span><br><span class="line"><span class="comment">        sortOrder是对结果进行排序</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        查询结果存放在Cursor对象中返回</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//其他方法中也类似，调用uriMatcher匹配查询的位置</span></span><br><span class="line">        <span class="keyword">switch</span>(uriMatcher.match(uri))&#123;</span><br><span class="line">            <span class="keyword">case</span> TABLE1_DIR:</span><br><span class="line">                <span class="comment">//查询该表的全部数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE1_ITEM:</span><br><span class="line">                <span class="comment">//查询该表下的某条数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE2_DIR:</span><br><span class="line">                <span class="comment">//同理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE1_ITEM:</span><br><span class="line">                <span class="comment">//同理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri,ContentValues values)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        想内容提供器中插入一条数据</span></span><br><span class="line"><span class="comment">        uri:确定插入的表</span></span><br><span class="line"><span class="comment">        values：插入的数据</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        添加成功后会返回表示该条新数据的uri</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri,ContentValues values,String selection,String[] selectionArgs)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        更新数据时调用该方法</span></span><br><span class="line"><span class="comment">        uri:同理</span></span><br><span class="line"><span class="comment">        values:新的数据</span></span><br><span class="line"><span class="comment">        selection、selectionArgs:更新的条件</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        返回更新了的行数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri,String selection,String[] selectionArgs)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        删除数据时调用</span></span><br><span class="line"><span class="comment">        uri:同理</span></span><br><span class="line"><span class="comment">        selection、selectionArgs：同理</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        返回被删除的行数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用该方法，是根据传入的uri返回相应的MIME类型</span></span><br><span class="line"><span class="comment">        MIME字符串主要由3部分组成:</span></span><br><span class="line"><span class="comment">        1.vnd开头</span></span><br><span class="line"><span class="comment">        2.如果URI以路径结尾，则后接android.cursor.dir/，</span></span><br><span class="line"><span class="comment">        若以id结尾，则接android.cursor.item/</span></span><br><span class="line"><span class="comment">        3.最后街上vnd.&lt;authority&gt;.&lt;path&gt;</span></span><br><span class="line"><span class="comment">        如下：</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">switch</span>(uriMatcher.match(uri))&#123;</span><br><span class="line">              <span class="keyword">case</span> TABLE1_DIR:</span><br><span class="line">                <span class="comment">//以路径结尾</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.dir/vnd.com.example.app.provider.table1"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE1_ITEM:</span><br><span class="line">                <span class="comment">//以id结尾</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.item/vnd.com.example.app.provider.table1"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE2_DIR:</span><br><span class="line">                <span class="comment">//同理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.dir/vnd.com.example.app.provider.table2"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE1_ITEM:</span><br><span class="line">                <span class="comment">//同理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.item/vnd.com.example.app.provider.table1"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整实现跨程序数据共享"><a href="#完整实现跨程序数据共享" class="headerlink" title="完整实现跨程序数据共享"></a>完整实现跨程序数据共享</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TABLE1_DIR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TABLE1_ITEM = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TABLE2_DIR = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TABLE1_ITEM = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现数据库的帮助类</span></span><br><span class="line">    <span class="keyword">private</span> MyDatabaseHelper dbHelper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UriMatcher uriMatcher;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        uriMatcher = <span class="keyword">new</span> UriMatcher(Uri.Matcher.NO_MATCH);</span><br><span class="line">        <span class="comment">//第一个参数为authority(一般为应用包名.provider)</span></span><br><span class="line">        <span class="comment">//第二个参数为path，即查询的表</span></span><br><span class="line">        <span class="comment">//第三个参数为自定义码</span></span><br><span class="line">        uriMatcher.addUri(<span class="string">"com.example.app.provider"</span>,<span class="string">"table1"</span>,TABLE1_DIR);</span><br><span class="line">        uriMatcher.addUri(<span class="string">"com.example.app.provider"</span>,<span class="string">"table1/#"</span>,TABLE1_ITEM);</span><br><span class="line">        uriMatcher.addUri(<span class="string">"com.example.app.provider"</span>,<span class="string">"table2"</span>,TABLE2_DIR);</span><br><span class="line">        uriMatcher.addUri(<span class="string">"com.example.app.provider"</span>,<span class="string">"table2/#"</span>,TABLE2_ITEM);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">OnCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建或更新数据库</span></span><br><span class="line">        dbHelper = <span class="keyword">new</span> MyDatabaseHelper(context,<span class="string">"dbName.db"</span>,<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//返回true代表初始化成功，false则为失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri,String[] projection,String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] selectionArgs,String sortOrder)</span></span>&#123;</span><br><span class="line">        <span class="comment">//查询数据库</span></span><br><span class="line">        SQLiteDatabase db = dbHelper.getReadableDatabase();</span><br><span class="line">        Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(uriMatcher.match(uri))&#123;</span><br><span class="line">            <span class="keyword">case</span> TABLE1_DIR:</span><br><span class="line">                curos = db.query(<span class="string">"tableName"</span>,projection,selection,selectionArgs,</span><br><span class="line">                                <span class="keyword">null</span>,<span class="keyword">null</span>,sortOrder);</span><br><span class="line">                <span class="comment">//查询该表的全部数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE1_ITEM:</span><br><span class="line">                <span class="comment">//获取查询的id值</span></span><br><span class="line">                String id = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                curos = db.query(<span class="string">"tableName"</span>,projection,<span class="string">"id = ?"</span>,<span class="keyword">new</span> String[]&#123;id&#125;,</span><br><span class="line">                                <span class="keyword">null</span>,<span class="keyword">null</span>,sortOrder);</span><br><span class="line">                <span class="comment">//查询该表下的某条数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE2_DIR:</span><br><span class="line">                <span class="comment">//类上</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE1_ITEM:</span><br><span class="line">                <span class="comment">//类上</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入操作与查询操作类似</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri,ContentValues values)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        想内容提供器中插入一条数据</span></span><br><span class="line"><span class="comment">        uri:确定插入的表</span></span><br><span class="line"><span class="comment">        values：插入的数据</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        添加成功后会返回表示该条新数据的uri</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新操作与查询操作类似</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri,ContentValues values,String selection,String[] selectionArgs)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        更新数据时调用该方法</span></span><br><span class="line"><span class="comment">        uri:同理</span></span><br><span class="line"><span class="comment">        values:新的数据</span></span><br><span class="line"><span class="comment">        selection、selectionArgs:更新的条件</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        返回更新了的行数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与查询操作类似</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri,String selection,String[] selectionArgs)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        删除数据时调用</span></span><br><span class="line"><span class="comment">        uri:同理</span></span><br><span class="line"><span class="comment">        selection、selectionArgs：同理</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        返回被删除的行数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用该方法，是根据传入的uri返回相应的MIME类型</span></span><br><span class="line"><span class="comment">        MIME字符串主要由3部分组成:</span></span><br><span class="line"><span class="comment">        1.vnd开头</span></span><br><span class="line"><span class="comment">        2.如果URI以路径结尾，则后接android.cursor.dir/，</span></span><br><span class="line"><span class="comment">        若以id结尾，则接android.cursor.item/</span></span><br><span class="line"><span class="comment">        3.最后街上vnd.&lt;authority&gt;.&lt;path&gt;</span></span><br><span class="line"><span class="comment">        如下：</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">switch</span>(uriMatcher.match(uri))&#123;</span><br><span class="line">              <span class="keyword">case</span> TABLE1_DIR:</span><br><span class="line">                <span class="comment">//以路径结尾</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.dir/vnd.com.example.app.provider.table1"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE1_ITEM:</span><br><span class="line">                <span class="comment">//以id结尾</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.item/vnd.com.example.app.provider.table1"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE2_DIR:</span><br><span class="line">                <span class="comment">//同理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.dir/vnd.com.example.app.provider.table2"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TABLE1_ITEM:</span><br><span class="line">                <span class="comment">//同理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.item/vnd.com.example.app.provider.table1"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    总体来说，内容提供器的具体操作，与数据库的操作类似，个人认为，其只是封装了数据库的操作，只对传入的路径进行增删改查操作，所以对其他路径的数据不会产生影响，所以安全。</p>
<h3 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h3><p>​    内容提供器的用法一般有两种：</p>
<p>1.使用现有的内容提供器读取和操作相应程序中的数据(如Android系统中的通讯录，短信，媒体库等)</p>
<p>2.创建自己的内容提供器给程序的数据提供外部访问接口（如上）</p>
<h4 id="ContentResolver的基本用法"><a href="#ContentResolver的基本用法" class="headerlink" title="ContentResolver的基本用法"></a>ContentResolver的基本用法</h4><p>​    使用ContentResolver类，实现访问内容提供器中提供的共享数据，通过Context中的getContentResolver()方法获取其实例。</p>
<p>​    ContentResolver提供了对数据的CRUD操作（增删改查）方法，分别是insert()、update()、delete()和query()方法。这些方法中均接受一个内容URI，该URI由authority（一般为应该包名.provider）和path（查询的表名）组成，如：</p>
<p>​    content://com.eaxmple.app.provider/table</p>
<p>​    在得到内容URI后，需将其解析为Uri对象，如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.pare(<span class="string">"content://com.eaxmple.app.provider/table"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后，利用该uri查询数据</span></span><br><span class="line">Cursor curso =context.getContentResolver().query(uri,projection,selection,selectionArgs,sortOrder);</span><br><span class="line"><span class="comment">//各参数与contentProvider中一样</span></span><br><span class="line"><span class="comment">//update(),insert(),delete()方法与数据库中的类似</span></span><br></pre></td></tr></table></figure>
<p>然后，通过移动游标的位置遍历Cursor的所有行，取出数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(cursor != null)&#123;</span><br><span class="line">    while(cursor.moveToNext())&#123;</span><br><span class="line">        String column1 = cursor.getString(cursor.getColumnIndex(&quot;column1&quot;));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    //使用完关闭释放</span><br><span class="line">    cursor.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 起白
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>